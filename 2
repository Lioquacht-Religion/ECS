// entity.rs

use std::sync::atomic::AtomicU32;

use super::component::ArchetypeId;

struct Entry{
    entity: Option<Entity>,
    generation: u32,
}

pub(crate) struct Entities {
    vec: Vec<Entry>,
    empty_indices: Vec<u32>,
    free_indices_barrier: AtomicU32,
    empty_indices_barrier: AtomicU32,
}

impl Entities{
    pub(crate) fn new() -> Self{
        Self { 
            vec: Vec::new(), 
            empty_indices: Vec::new(), 
            free_indices_barrier: AtomicU32::new(0), 
            empty_indices_barrier: AtomicU32::new(0), 
        }
    }

    pub(crate) fn insert(&mut self, entity: Entity) -> EntityKey{
        if let Some(empty_index) = self.empty_indices.pop(){
            let entry = &mut self.vec[empty_index as usize];
            entry.entity = Some(entity);
            entry.generation += 1;
            EntityKey::new(empty_index, entry.generation)
        }
        else{
            let next_id = self.vec.len()
                .try_into()
                .expect("Only ids in the range of an u32 are allowed!");
            self.vec.push(Entry{
                entity: Some(entity), generation: 0
            });
            EntityKey::new(next_id, 0)
        }
    }
}

//TODO: what about generational index?
#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]
pub struct EntityId(u32);

#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]
pub struct EntityKey{
    pub(crate) id : u32,
    pub(crate) generation : u32,
}

impl EntityKey{
    pub(crate) fn new(id: u32, generation: u32) -> Self{
        Self{ id, generation }
    }

    pub(crate) fn get_id(&self) -> u32{
        self.id
    }

    pub(crate) fn get_generation(&self) -> u32{
        self.generation
    }
}

#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]
pub struct Entity {
    pub(crate) archetype_id: ArchetypeId,
    pub(crate) row_id: u32,
}
